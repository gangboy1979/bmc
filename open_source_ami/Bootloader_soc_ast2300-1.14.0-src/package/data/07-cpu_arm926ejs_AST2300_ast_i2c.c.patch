--- u-boot-1.1.6/cpu/arm926ejs/AST2300/ast_i2c.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6-ami/cpu/arm926ejs/AST2300/ast_i2c.c	2010-01-20 15:49:55.000000000 +0800
@@ -0,0 +1,236 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_I2C)
+#include <i2c.h>
+
+#include <ast2300_hw.h>
+
+#define I2C_CHANNEL_ID				CFG_I2C_CHANNEL_ID
+
+#define AST_I2C_REG_BASE			0x1E78A000 /* I2C controller registers base address */
+#define AST_I2C_CHANNEL_BASE		(AST_I2C_REG_BASE + (0x040 * (I2C_CHANNEL_ID + 1)))
+
+/* I2C device registers offset */
+#define I2C_DISR	AST_I2C_REG_BASE /* I2C controller device interrupt status register */
+#define I2C_FCR		(AST_I2C_CHANNEL_BASE + 0x00) /* function control register */
+#define I2C_CATCR1	(AST_I2C_CHANNEL_BASE + 0x04) /* clock and AT timming control register 1 */
+#define I2C_CATCR2	(AST_I2C_CHANNEL_BASE + 0x08) /* clock and AT timming control register 2 */
+#define I2C_ICR		(AST_I2C_CHANNEL_BASE + 0x0C) /* interrupt control register */
+#define I2C_ISR		(AST_I2C_CHANNEL_BASE + 0x10) /* interrupt status register */
+#define I2C_CSR		(AST_I2C_CHANNEL_BASE + 0x14) /* command/status register */
+#define I2C_DR		(AST_I2C_CHANNEL_BASE + 0x18) /* device address register */
+#define I2C_BCR		(AST_I2C_CHANNEL_BASE + 0x1C) /* buffer control register */
+#define I2C_TRBB	(AST_I2C_CHANNEL_BASE + 0x20) /* transmit/receive byte buffer */
+#define I2C_DMCR	(AST_I2C_CHANNEL_BASE + 0x24) /* DMA mode control register */
+#define I2C_DMSR	(AST_I2C_CHANNEL_BASE + 0x28) /* DMA mode status register */
+
+/* I2C operations */
+#define I2C_WRITE 0
+#define I2C_READ 1
+
+static int i2c_start(unsigned char chip, unsigned char read_write);
+static void i2c_stop(void);
+static unsigned long i2c_interrupt_status(void);
+static int i2c_send_byte(unsigned char byte);
+static int i2c_receive_byte(unsigned char *byte, int last);
+
+/*
+ * Initialization, must be called once on start up, may be called
+ * repeatedly to change the speed and slave addresses.
+ */
+void i2c_init (int speed, int slaveadd)
+{
+	volatile unsigned long scu_reg;
+
+	*((volatile ulong *) SCU_KEY_CONTROL_REG) = 0x1688A8A8; /* unlock SCU */
+
+	/* stop I2C controller reset */
+	scu_reg = *((volatile ulong *) SCU_SYS_RESET_REG);
+	*((volatile ulong *) SCU_SYS_RESET_REG) = scu_reg & ~(0x04);
+
+	//*((volatile ulong *) SCU_KEY_CONTROL_REG) = 0; /* lock SCU */
+
+    /* Set Clock and AC timing Control Register 1 and 2 */
+    /* the divisor is 256 */
+	*((volatile unsigned long *) I2C_CATCR1) = 0x77777344;
+	*((volatile unsigned long *) I2C_CATCR2) = 0x00000000;
+
+    /* Set Slave address */
+    *((volatile unsigned long *) I2C_DR) = slaveadd;
+
+    /* Clear Interrupt Status register */
+    *((volatile unsigned long *) I2C_ISR) = 0xFFFFFFFF; /* write 1 to clear bits */
+
+    /* Set Master or Slave mode */
+    *((volatile unsigned long *) I2C_FCR) = 0x01; /* master function enable only */
+
+    /* Set Interrupt Control register */
+	*((volatile unsigned long *) I2C_ICR) = 0x0000002F;
+}
+
+/*
+ * Probe the given I2C chip address.  Returns 0 if a chip responded,
+ * not 0 on failure.
+ */
+int i2c_probe(uchar chip)
+{
+	int ret;
+	
+	i2c_init(CFG_I2C_SPEED, CFG_I2C_SLAVE);
+
+	ret = 0;
+	if (i2c_start(chip, I2C_WRITE)) /* Do not use I2C_READ or the bus will be blocked by salve */
+		ret = 1;
+
+	i2c_stop();
+
+	return ret;
+}
+
+int i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	int i;
+	int last;
+	int ret;
+
+	ret = 0;
+
+	if (i2c_start(chip, I2C_WRITE))
+		return 1;
+
+	for (i = 0; i < alen; i ++) {
+		if (i2c_send_byte((addr >> ((alen -1 - i) * 8)) & 0xFF)) {
+			return 1;
+		}
+	}
+
+	if (i2c_start(chip, I2C_READ))
+		return 1;
+
+	for (i = 0; i < len; i ++) {
+		last = (i < (len - 1)) ? 0 : 1;
+		if (i2c_receive_byte(&(buffer[i]), last)) {
+			ret = 1;
+		}
+	}
+
+	i2c_stop();
+
+	return ret;
+}
+
+int i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	int i;
+	int last;
+	int ret;
+
+	ret = 0;
+
+	if (i2c_start(chip, I2C_WRITE))
+		return 1;
+
+	for (i = 0; i < alen; i ++) {
+		if (i2c_send_byte((addr >> ((alen -1 - i) * 8)) & 0xFF)) {
+			return 1;
+		}
+	}
+
+	for (i = 0; i < len; i ++) {
+		last = (i < (len - 1)) ? 0 : 1;
+		if (i2c_send_byte(buffer[i])) {
+			ret = 1;
+		}
+	}
+
+	i2c_stop();
+
+	return ret;
+}
+
+uchar i2c_reg_read(uchar i2c_addr, uchar reg)
+{
+	unsigned char buf;
+
+	i2c_read(i2c_addr, reg, 1, &buf, 1);
+
+	return buf;
+}
+
+void i2c_reg_write(uchar i2c_addr, uchar reg, uchar val)
+{
+	i2c_write(i2c_addr, reg, 1, &val, 1);
+}
+
+static int i2c_send_byte(unsigned char byte)
+{
+	*((volatile unsigned long *) I2C_TRBB) = byte & 0x000000FF;
+	*((volatile unsigned long *) I2C_CSR) = 0x02; /* master transmit command */
+
+	if (!(i2c_interrupt_status() & 0x01)) { /* transmit done with ACK returned */
+		return 1;
+	}
+
+    return 0;
+}
+
+static int i2c_receive_byte(unsigned char *byte, int last)
+{
+	*((volatile unsigned long *) I2C_CSR) = 0x08 | (last << 4); /* master receive command, master/slave receive command last */
+
+	if (!(i2c_interrupt_status() & 0x04)) { /* receive done interrupt */
+		return 1;
+	}
+
+	*byte = (unsigned char) ((*((volatile unsigned long *) I2C_TRBB) & 0x0000FF00) >> 8);
+
+	return 0;
+}
+
+static int i2c_start(unsigned char chip, unsigned char read_write)
+{
+	*((volatile unsigned long *) I2C_TRBB) = (chip  << 1) | (read_write & 0x1); /* load address to buffer and specify read/write */
+	*((volatile unsigned long *) I2C_CSR) = 0x03; /* master start command, master transmit command */
+
+	if (i2c_interrupt_status() & 0x01) { /* transmit done with ACK returned interrupt */
+		return 0;
+	}
+
+	return 1;
+}
+
+static void i2c_stop(void)
+{
+	*((volatile unsigned long *) I2C_CSR) = 0x0030; /* master stop command */
+}
+
+static unsigned long i2c_interrupt_status(void)
+{
+	unsigned char isr; /* device interrupt status register */
+	unsigned char device_bit;
+	unsigned long interrup_status;
+	long i;
+
+	interrup_status = 0;
+	
+	for (i = 0; i < 100000; i ++) { /* poll device interrupt status */
+		isr = *((volatile unsigned long *) I2C_DISR);
+
+		device_bit = 0x01 << I2C_CHANNEL_ID;
+		if ((isr & device_bit) != 0) { /* interrupt occurs */
+			interrup_status = *((volatile unsigned long *) I2C_ISR);
+			break;
+		}
+	}
+
+	#if 0
+	if (i == 100000)
+		printf("i2c time out! ISR = 0x%X\n", *((volatile unsigned long *) I2C_ISR]);
+	#endif
+
+	*((volatile unsigned long *) I2C_ISR) = 0xFFFFFFFF; /* clear bits */
+
+	return interrup_status;
+}
+
+#endif /* CFG_CMD_I2C */
