--- u-boot-1.1.6/cpu/arm926ejs/AST2300/kcsregs.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6-ami/cpu/arm926ejs/AST2300/kcsregs.h	2010-01-18 10:37:10.000000000 +0800
@@ -0,0 +1,288 @@
+/*****************************************************************
+ *****************************************************************
+ ***                                                            **
+ ***    (C)Copyright 2002-2003, American Megatrends Inc.        **
+ ***                                                            **
+ ***            All Rights Reserved.                            **
+ ***                                                            **
+ ***        6145-F, Northbelt Parkway, Norcross,                **
+ ***                                                            **
+ ***        Georgia - 30071, USA. Phone-(770)-246-8600.         **
+ ***                                                            **
+ *****************************************************************
+ *****************************************************************
+ *****************************************************************
+ * $Header: $
+ *
+ * $Revision: $
+ *
+ * $Date: $
+ *
+ ******************************************************************
+ ******************************************************************
+ * 
+ * KCSRegs.h
+ * KCS Register definitions
+ *
+ *  Author: Rama Rao Bisa <ramab@ami.com>
+ *			Modified by Anurag Bhatia for Pilot-II porting
+ ******************************************************************/
+#ifndef KCS_REGS_H
+#define KCS_REGS_H
+
+#include <ast2300_hw.h>
+
+/* LPC Base Address */ 
+#define AST_LPC_BASE		0x1E789000
+#define LPC_BASE_ADDR           AST_LPC_BASE
+
+/* Register Definitions */
+#define HICR0				0x00
+#define HICR1				0x04
+#define HICR2				0x08
+#define HICR3				0x0C
+#define HICR4				0x10
+#define LADR3H				0x14
+#define LADR3L				0x18
+#define LADR12H				0x1C
+#define LADR12L				0x20
+
+#define KCS_IDR1			0x24
+#define KCS_IDR2			0x28
+#define KCS_IDR3			0x2C
+#define KCS_ODR1			0x30	
+#define KCS_ODR2			0x34
+#define KCS_ODR3			0x38
+#define KCS_STATUS_1		0x3C	
+#define KCS_STATUS_2		0x40
+#define KCS_STATUS_3		0x44
+
+#define BIT0	0x01
+#define BIT1	0x02
+#define BIT2	0x04
+#define BIT3	0x08
+#define BIT4	0x10
+#define BIT5	0x20
+#define BIT6	0x40
+#define BIT7	0x80
+
+#define	KCS_1_CHANNEL			0
+#define	KCS_2_CHANNEL			1
+
+#define MAX_KCS_CHANNELS		    2
+
+
+/* Macro to access registers and memory */
+//#define WRITE_DWORD(reg,data) 	*((volatile unsigned long *)(reg)) = (data)
+
+#define WRITE_U8(reg,data)			*((volatile unsigned long *)(reg)) = (data)
+#define READ_U8(reg)					*((volatile unsigned long *)(reg))
+
+/*** Local Macro Definitions ***/
+/**
+ * @def WRITE_KCS_STATUS_REG
+ * @brief Writes a byte into KCS port status register.
+ * @param CHANNEL The KCS channel number.
+ * @param STATUS a byte data.
+ **/
+#define WRITE_KCS_STATUS_REG(CHANNEL, STATUS)			                 						 \
+do {                                     			                 			 			     \
+    switch (CHANNEL){                      				         						         \
+    case KCS_1_CHANNEL: WRITE_U8 (lpc_base + KCS_STATUS_3,STATUS); break;         \
+    case KCS_2_CHANNEL: WRITE_U8 (lpc_base + KCS_STATUS_2,STATUS); break;         \
+    }                                                  				    						 \
+} while (0)
+
+
+/**
+ * @def READ_KCS_STATUS_REG
+ * @brief Reads a byte from KCS port status register.
+ * @param CHANNEL The KCS channel number.
+ * @param STATUS a byte data.
+ **/
+#define READ_KCS_STATUS_REG(CHANNEL, STATUS)             								     \
+do {                                                     								     \
+    switch (CHANNEL) {                                   								     \
+    case KCS_1_CHANNEL: STATUS = READ_U8(lpc_base + KCS_STATUS_3); break;   	 \
+    case KCS_2_CHANNEL: STATUS = READ_U8(lpc_base + KCS_STATUS_2); break;   	 \
+    }                                                      									 \
+} while (0)
+
+/**
+ * @def KCS_DATA_OUT_REG
+ * @brief Writes a byte into KCS port data register.
+ * @param CHANNEL The KCS channel number.
+ * @param DATA a byte data.
+ **/
+#define KCS_DATA_OUT_REG(CHANNEL, DATA)        				            					 \
+do {                                           				             					 \
+    switch (CHANNEL) {                        				             					 \
+    case KCS_1_CHANNEL: WRITE_U8 (lpc_base + KCS_ODR3,DATA); break;           \
+    case KCS_2_CHANNEL: WRITE_U8 (lpc_base + KCS_ODR2,DATA); break;           \
+    }                                               				      					 \
+} while (0)
+
+
+/**
+ * @def KCS_DATA_IN_REG
+ * @brief Reads a byte from KCS port data register.
+ * @param CHANNEL The KCS channel number.
+ * @param DATA a byte data.
+ **/
+#define KCS_DATA_IN_REG(CHANNEL, DATA)        				   		    				 \
+do {                                        				  	 				         \
+    switch (CHANNEL) {                                     								 \
+    case KCS_1_CHANNEL: DATA = READ_U8(lpc_base + KCS_IDR3); break;   		 \
+    case KCS_2_CHANNEL: DATA = READ_U8(lpc_base + KCS_IDR2); break;   		 \
+    }                                                      				  				 \
+} while (0)
+
+
+/**
+ * @def KCS_CMD_REG
+ * @brief Reads a byte from KCS port command register.
+ * @param CHANNEL The KCS channel number.
+ * @param CMD a byte data.
+ **/
+#define KCS_CMD_REG(CHANNEL, CMD)         								                 \
+do {                                            				                         \
+    switch (CHANNEL) {                       				                             \
+    case KCS_1_CHANNEL: CMD = READ_U8(lpc_base + KCS_IDR3); break;   		 \
+    case KCS_2_CHANNEL: CMD = READ_U8(lpc_base + KCS_IDR2); break;   		 \
+    }                                            				         				 \
+} while (0)
+
+
+/** 
+ * @def CLEAR_IBF_STATUS
+**/
+#define CLEAR_IBF_STATUS(CHANNEL)
+
+/** 
+ * @def SET_OBF_STATUS
+**/
+#define SET_OBF_STATUS(CHANNEL)
+
+
+#define ENABLE_KCS_ADDRESS_SELECT(CHANNEL)     				              \
+do {                    												  \
+	unsigned char temp;                    				              		  \
+    switch (CHANNEL) {                                     				  \
+    case KCS_1_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR4);					  \
+		temp |= BIT2;													  \
+		temp &= ~BIT0;													  \
+		WRITE_U8 (lpc_base+ HICR4,temp);					  \
+	break;   															  \
+    case KCS_2_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR4);					  \
+		temp |= BIT7;													  \
+		WRITE_U8 (lpc_base+ HICR4,temp);				  \
+	break;   															  \
+    }                                                      				  \
+} while (0)
+
+#define SET_KCS_ADDRESS(CHANNEL, ADDR) 						              			\
+do {                    												  			\
+	int temp = ADDR;                   				              		  			\
+    switch (CHANNEL) {                                     				  			\
+    case KCS_1_CHANNEL:													  			\
+		WRITE_U8 (lpc_base + LADR3H, (unsigned char)(temp >> 8));		  	\
+		WRITE_U8 (lpc_base + LADR3L, (unsigned char)(temp & 0xFA));			\
+	break;   															 			\
+    case KCS_2_CHANNEL:													  			\
+		WRITE_U8 (lpc_base +LADR12H, (unsigned char)(temp >> 8));		  	\
+		WRITE_U8 (lpc_base +LADR12L, (unsigned char)(temp));		  		\
+	break;   															  			\
+    }                                                      				  			\
+} while (0)
+
+#define ENABLE_KCS_CHANNEL(CHANNEL)				 			              \
+do {                    												  \
+	unsigned char temp;                    				              		  \
+    switch (CHANNEL) {                                     				  \
+    case KCS_1_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR0);					  \
+		temp |= BIT7;													  \
+		WRITE_U8 (lpc_base + HICR0,temp);				  \
+	break;   															  \
+    case KCS_2_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR0);					  \
+		temp |= BIT6;													  \
+		WRITE_U8 (lpc_base + HICR0,temp);				  \
+	break;   															  \
+    }                                                      				  \
+} while (0)
+
+/**
+ * @def INIT_KCS
+ * @brief Enables KCS channel 1
+ **/
+#define INIT_KCS_HARDWARE() 			                    					\
+do {                                                        					\
+	CLEAR_IBF_STATUS(0);															\
+	CLEAR_IBF_STATUS(1);															\
+} while (0) 
+
+
+
+#define DISABLE_KCS_INTRS(CHANNEL)				 			              \
+do {                    												  \
+	u8 temp;                    				              		  \
+    switch (CHANNEL) {                                     				  \
+    case KCS_1_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR2);					  \
+		temp &= (~BIT3);											  \
+		WRITE_U8(lpc_base + HICR2,temp);				  \
+	break;   															  \
+    case KCS_2_CHANNEL:													  \
+		temp = READ_U8(lpc_base + HICR2);					  \
+		temp &= (~BIT2);											  \
+		WRITE_U8(lpc_base + HICR2,temp);				  \
+	break;   															  \
+    }                                                      				  \
+} while (0)
+
+/** 
+ * @def SMS_KCS_BASE_ADDR
+ * @brief SMS KCS Base address
+**/
+#define SMS_KCS_BASE_ADDR		0xCA2
+
+/** 
+ * @def OBF_BIT_SET
+ * @brief Macro to check if output buffer is full
+**/
+#define OBF_BIT_SET(STATUS_REG) (0 != ((STATUS_REG) & 0x01))
+
+/** 
+ * @def IBF_BIT_SET
+ * @brief Macro to check if input buffer is full
+**/
+#define IBF_BIT_SET(STATUS_REG) (0 != ((STATUS_REG) & 0x02))
+
+/** 
+ * @def SET_KCS_STATE
+ * @brief Macro to set the current state of the KCS Interface.
+**/
+#define SET_KCS_STATE(CHANNEL, STATE) 									\
+do {																	\
+	u8 Status = 0;														\
+	READ_KCS_STATUS_REG ((CHANNEL), Status);							\
+	Status = ((Status & (~0xC0)) | (STATE));							\
+	WRITE_KCS_STATUS_REG ((CHANNEL),Status);							\
+} while (0)
+
+/** 
+ * @def IS_WRITE_TO_CMD_REG
+ * @brief Macro that returns true if last write was to command register.
+**/
+#define IS_WRITE_TO_CMD_REG(STATUS_REG) (0 != ((STATUS_REG) & 0x08))
+
+/** 
+ * @def IS_WRITE_TO_DATA_REG
+ * @brief Macro that returns true if last write was to data register.
+**/
+#define IS_WRITE_TO_DATA_REG(STATUS_REG) (0 == ((STATUS_REG) & 0x08))
+
+#endif  /* KCS_REGS_H */
