diff -Naur busybox_old/include/libbb.h busybox/include/libbb.h
--- busybox_old/include/libbb.h	2011-06-29 02:20:59.292168797 +0900
+++ busybox/include/libbb.h	2011-06-29 02:35:41.268093330 +0900
@@ -488,6 +488,8 @@
 int create_and_connect_stream_or_die(const char *peer, int port) FAST_FUNC;
 /* Connect to peer identified by lsa */
 int xconnect_stream(const len_and_sockaddr *lsa) FAST_FUNC;
+/* Get remote address of connected or accepted socket */
+len_and_sockaddr *get_peer_lsa(int fd);
 /* Return malloc'ed len_and_sockaddr with socket address of host:port
  * Currently will return IPv4 or IPv6 sockaddrs only
  * (depending on host), but in theory nothing prevents e.g.
diff -Naur busybox_old/libbb/xconnect.c busybox/libbb/xconnect.c
--- busybox_old/libbb/xconnect.c	2011-06-29 02:20:59.595260041 +0900
+++ busybox/libbb/xconnect.c	2011-06-29 02:35:41.900099489 +0900
@@ -4,6 +4,7 @@
  *
  * Connect to host at port using address resolution from getaddrinfo
  *
+ * Licensed under GPLv2, see file LICENSE in this source tree
  */
 
 #include <netinet/in.h>
@@ -41,6 +42,30 @@
 	return r;
 }
 
+static len_and_sockaddr* get_lsa(int fd, int (*get_name)(int fd, struct sockaddr *addr, socklen_t *addrlen))
+{
+	len_and_sockaddr lsa;
+	len_and_sockaddr *lsa_ptr;
+
+	lsa.len = LSA_SIZEOF_SA;
+	if (get_name(fd, &lsa.u.sa, &lsa.len) != 0)
+		return NULL;
+
+	lsa_ptr = xzalloc(LSA_LEN_SIZE + lsa.len);
+	if (lsa.len > LSA_SIZEOF_SA) { /* rarely (if ever) happens */
+		lsa_ptr->len = lsa.len;
+		get_name(fd, &lsa_ptr->u.sa, &lsa_ptr->len);
+	} else {
+		memcpy(lsa_ptr, &lsa, LSA_LEN_SIZE + lsa.len);
+	}
+	return lsa_ptr;
+}
+
+
+len_and_sockaddr* FAST_FUNC get_peer_lsa(int fd)
+{
+	return get_lsa(fd, getpeername);
+}
 
 void FAST_FUNC xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen)
 {
diff -Naur busybox_old/loginutils/login.c busybox/loginutils/login.c
--- busybox_old/loginutils/login.c	2011-06-29 02:21:00.053232546 +0900
+++ busybox/loginutils/login.c	2011-06-29 02:35:43.062779611 +0900
@@ -21,7 +21,8 @@
  * Apparently they like to confuse people. */
 #include <security/pam_appl.h>
 #include <security/pam_misc.h>
-
+#include <string.h>
+#define MAX_NAME_LEN 25
 int bb_conv(int num_msg,const struct pam_message **msg,struct pam_response **resp,void *appdata_ptr);
 
 static const struct pam_conv conv = {
@@ -336,6 +337,21 @@
 	struct passwd pwdstruct;
 	char pwdbuf[256];
 	char *getpasswd;
+	char hostname[MAX_NAME_LEN];
+	pid_t pid;
+	int status;
+
+	memset (hostname, 0, sizeof (hostname));
+	/*if the first argument is NULL or not equals to  -h just give the loopback address.
+	telnet login always gives the argv[1] = -h and normal login pass the argument according
+	to user options example: "login -f user" or login*/
+	if ((NULL == argv[1]) || (0 != strcmp("-h", argv[1]))){
+		memcpy (hostname, "127.0.0.1", sizeof (hostname));
+	}
+	else if (NULL != argv[2]) {
+		sprintf (hostname, "%s", argv[2]);
+	}
+
 #endif
 
 	short_tty = full_tty;
@@ -410,6 +426,12 @@
 			failed_msg = "set_item(TTY)";
 			goto pam_auth_failed;
 		}
+		/*Set the remote hsot name */
+		pamret = pam_set_item(pamh, PAM_RHOST, hostname);
+		if (pamret != PAM_SUCCESS) {
+			failed_msg = "set_item(PAM_RHOST)";
+			goto pam_auth_failed;
+		}
 
 	        getpasswd = bb_askpass(0, "Password: ");
         	if (!getpasswd) {
@@ -599,8 +621,21 @@
 	 * should we leave SIGINT etc enabled or disabled? */
 	signal(SIGINT, SIG_DFL);
 
+#if ENABLE_PAM
+	/*Use fork to get the control back*/
+	pid = fork ();
+	if (pid == 0){
+		run_shell(tmp, 1, NULL, NULL);
+	}else{
+		/*Wait until process exit*/
+		waitpid (pid, &status, 0);
+		/*Call the close session for logout audits*/
+		pam_close_session (pamh,PAM_SILENT);
+	}
+#else
 	/* Exec login shell with no additional parameters */
 	run_shell(tmp, 1, NULL, NULL);
-
+#endif
+	return 0;
 	/* return EXIT_FAILURE; - not reached */
 }
diff -Naur busybox_old/networking/telnetd.c busybox/networking/telnetd.c
--- busybox_old/networking/telnetd.c	2011-06-29 02:20:59.812085259 +0900
+++ busybox/networking/telnetd.c	2011-06-29 02:35:42.344119097 +0900
@@ -170,11 +170,13 @@
 		USE_FEATURE_TELNETD_STANDALONE(int sock)
 		SKIP_FEATURE_TELNETD_STANDALONE(void)
 ) {
-	const char *login_argv[2];
+	const char *login_argv[4];
+	char *hostname = NULL;
 	struct termios termbuf;
 	int fd, pid;
 	char tty_name[GETPTY_BUFSIZE];
 	struct tsession *ts = xzalloc(sizeof(struct tsession) + BUFSIZE * 2);
+	len_and_sockaddr *lsa=NULL;
 
 	/*ts->buf1 = (char *)(ts + 1);*/
 	/*ts->buf2 = ts->buf1 + BUFSIZE;*/
@@ -245,6 +247,14 @@
 
 	/* Restore default signal handling */
 	bb_signals((1 << SIGCHLD) + (1 << SIGPIPE), SIG_DFL);
+	/*Get the hostname*/
+	lsa = get_peer_lsa(sock);
+        if (lsa) {
+		/*convert it into string pattern */
+		hostname = xmalloc_sockaddr2dotted_noport(&lsa->u.sa);
+                free(lsa);
+        }
+
 
 	/* open the child's side of the tty. */
 	/* NB: setsid() disconnects from any previous ctty's. Therefore
@@ -275,7 +285,10 @@
 
 	/* Exec shell / login / whatever */
 	login_argv[0] = loginpath;
-	login_argv[1] = NULL;
+	login_argv[1] = "-h";
+	/*ipv4 address is from 7th byte onwards*/
+	login_argv[2] = (hostname+7);
+	login_argv[3] = NULL;
 	/* exec busybox applet (if PREFER_APPLETS=y), if that fails,
 	 * exec external program */
 	BB_EXECVP(loginpath, (char **)login_argv);
