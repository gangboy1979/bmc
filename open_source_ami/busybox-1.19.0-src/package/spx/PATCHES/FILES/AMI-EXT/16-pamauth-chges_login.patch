--- busybox_old/loginutils/login.c	2011-06-06 11:28:10.062922728 +0900
+++ busybox/loginutils/login.c	2011-06-06 11:19:12.560925841 +0900
@@ -21,10 +21,14 @@
  * Apparently they like to confuse people. */
 #include <security/pam_appl.h>
 #include <security/pam_misc.h>
+
+int bb_conv(int num_msg,const struct pam_message **msg,struct pam_response **resp,void *appdata_ptr);
+
 static const struct pam_conv conv = {
-	misc_conv,
+	bb_conv,
 	NULL
 };
+static const char *bb_password = NULL;
 #endif
 
 enum {
@@ -217,6 +221,93 @@
 	_exit(EXIT_SUCCESS);
 }
 
+
+/*
+ * *@fn bb_conv
+ * *@brief conversation function for direct communication b/w loaded module and application.
+ * * In conventional misc_conv  password prompting happens multi times for authentication failure in each PAM module.
+ * * bb_conv provides the password to the module for authentication.
+ * *		@param num_msg     - Number of messages
+ * *		@param pam_message - Array of messages to application  PAM Module.
+ * *		@param resp   - PAM respose structure.
+ * *		@param appdata_ptr- data ptr.
+ * *		@return Returns error on conversation failure.
+ * */
+
+int bb_conv(int num_msg,const struct pam_message **msg,struct pam_response **resp,void *appdata_ptr)
+{
+	struct pam_response *bb_resp;
+	int i;
+
+	*resp = NULL;
+
+	if (num_msg <= 0 || num_msg > PAM_MAX_NUM_MSG)
+	{	
+		printf("\n Exceeding Maximum numbef of messages in the pam conversation function...\n");
+		*resp = NULL;
+		return (PAM_CONV_ERR);
+	}
+
+	//allocate as many responses as num messages
+	bb_resp = (struct pam_response *)calloc( num_msg, sizeof(struct pam_response));
+	if(bb_resp == NULL)
+	{
+		printf("\n Allocating memory for pam_respose failed........\n");
+		return (PAM_CONV_ERR);
+	}
+
+	for(i=0; i < num_msg; i++)
+	{
+		switch (msg[i]->msg_style)
+		{
+			case PAM_PROMPT_ECHO_OFF:
+				if (bb_password == NULL)
+					goto fail_conv;
+				if ((bb_resp[i].resp = strdup(bb_password)) == NULL)
+					goto fail_conv;
+				bb_resp[i].resp_retcode = PAM_SUCCESS;
+				break;
+
+			case PAM_PROMPT_ECHO_ON:
+				/*for security reason*/
+				goto fail_conv;
+
+			case PAM_ERROR_MSG:
+				if (fprintf(stderr, "%s\n", msg[i]->msg) < 0) 		
+					goto fail_conv;
+				if ((bb_resp[i].resp = strdup("")) == NULL)
+					goto fail_conv;
+				bb_resp[i].resp_retcode = PAM_SUCCESS;
+				break;
+
+			case PAM_TEXT_INFO:
+				if (fprintf(stdout, "%s\n", msg[i]->msg) < 0) 				    
+					goto fail_conv;
+				if ((bb_resp[i].resp = strdup("")) == NULL)
+					goto fail_conv;
+				bb_resp[i].resp_retcode = PAM_SUCCESS;
+				break;
+			default:
+				goto fail_conv;
+		}
+	}
+
+	*resp = bb_resp;
+	appdata_ptr = appdata_ptr;	
+	return (PAM_SUCCESS);
+
+    fail_conv:
+		printf("\n login.c: bb_conv failed\n");
+		for(i = 0; i < num_msg; i++)
+		{
+			if (bb_resp[i].resp != NULL)
+				free(bb_resp[i].resp);
+		}
+		free(bb_resp);
+		return (PAM_CONV_ERR);
+}
+
+
 int login_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int login_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -244,6 +335,7 @@
 	const char *failed_msg;
 	struct passwd pwdstruct;
 	char pwdbuf[256];
+	char *getpasswd;
 #endif
 
 	short_tty = full_tty;
@@ -305,17 +397,27 @@
 			get_username_or_die(username, sizeof(username));
 
 #if ENABLE_PAM
+
 		pamret = pam_start("login", username, &conv, &pamh);
 		if (pamret != PAM_SUCCESS) {
 			failed_msg = "start";
 			goto pam_auth_failed;
 		}
+
 		/* set TTY (so things like securetty work) */
 		pamret = pam_set_item(pamh, PAM_TTY, short_tty);
 		if (pamret != PAM_SUCCESS) {
 			failed_msg = "set_item(TTY)";
 			goto pam_auth_failed;
 		}
+
+	        getpasswd = bb_askpass(0, "Password: ");
+        	if (!getpasswd) {
+			return 0;
+        	}
+
+		bb_password = getpasswd;
+
 		pamret = pam_authenticate(pamh, 0);
 		if (pamret != PAM_SUCCESS) {
 			failed_msg = "authenticate";
